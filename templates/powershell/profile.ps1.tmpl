# PowerShell Profile Configuration
# Generated by dotfiles-go
# Platform: {{.Platform.OS}}/{{.Platform.Architecture}}{{if .Platform.WSL}} (WSL2: {{.Platform.WSL.Distribution}}){{end}}
# Generated at: {{now | date "2006-01-02 15:04:05"}}
{{if .Platform.PowerShell}}# PowerShell: {{.Platform.PowerShell.Version}} ({{.Platform.PowerShell.Edition}}){{end}}

# =============================================================================
# PowerShell Profile - Modern Developer Environment
# =============================================================================

# Performance: Track profile loading time
$ProfileStartTime = Get-Date

#region Environment Setup
Write-Host "üöÄ Loading PowerShell Profile..." -ForegroundColor Cyan

# Basic environment variables
$env:EDITOR = "{{.User.Editor | default "code"}}"
$env:BROWSER = "{{.User.Browser | default "msedge"}}"

{{range $key, $value := .Environment}}
$env:{{$key}} = "{{expandEnv $value}}"
{{end}}

{{if .Platform.WSL}}
{{if .Platform.WSL.WindowsHome}}
# WSL2 Integration
$env:WINHOME = "{{.Platform.WSL.WindowsHome}}"
$env:WINDOWS_HOME = "{{.Platform.WSL.WindowsHome}}"

# Cross-platform functions
function winhome { Set-Location $env:WINHOME }
function winproj { Set-Location "$env:WINHOME\Projects" }
{{end}}
{{end}}

# Development paths
{{if .Paths.Projects.Default}}
$env:PROJECTS_DIR = "{{expandEnv (.Paths.Projects.Get "windows")}}"
{{else}}
$env:PROJECTS_DIR = "$env:USERPROFILE\Projects"
{{end}}

function projects { Set-Location $env:PROJECTS_DIR }
function proj { Set-Location $env:PROJECTS_DIR }

#endregion

{{if .ZshConfig.Proxy.Enabled}}
#region Proxy Configuration
{{$activeProfile := .ZshConfig.Proxy.ActiveProfile}}
{{$profile := index .ZshConfig.Proxy.Profiles $activeProfile}}
{{if $profile}}
{{if ne $profile.HTTPSProxy ""}}
$env:HTTPS_PROXY = "{{expandEnv $profile.HTTPSProxy}}"
{{end}}
{{if ne $profile.HTTPProxy ""}}
$env:HTTP_PROXY = "{{expandEnv $profile.HTTPProxy}}"
{{end}}
{{if ne $profile.AllProxy ""}}
$env:ALL_PROXY = "{{expandEnv $profile.AllProxy}}"
{{end}}
{{if ne $profile.NoProxy ""}}
$env:NO_PROXY = "{{expandEnv $profile.NoProxy}}"
{{end}}
{{end}}

function Enable-Proxy {
    param(
        [ValidateSet({{range $name, $profile := .ZshConfig.Proxy.Profiles}}"{{$name}}", {{end}})]
        [string]$Profile = "{{$activeProfile}}"
    )
    
    switch ($Profile) {
        {{range $name, $profile := .ZshConfig.Proxy.Profiles}}
        "{{$name}}" {
            {{if ne $profile.HTTPSProxy ""}}
            $env:HTTPS_PROXY = "{{expandEnv $profile.HTTPSProxy}}"
            {{end}}
            {{if ne $profile.HTTPProxy ""}}
            $env:HTTP_PROXY = "{{expandEnv $profile.HTTPProxy}}"
            {{end}}
            {{if ne $profile.AllProxy ""}}
            $env:ALL_PROXY = "{{expandEnv $profile.AllProxy}}"
            {{end}}
            {{if ne $profile.NoProxy ""}}
            $env:NO_PROXY = "{{expandEnv $profile.NoProxy}}"
            {{end}}
        }
        {{end}}
    }
    Write-Host "‚úÖ Proxy enabled: $Profile" -ForegroundColor Green
}

function Disable-Proxy {
    Remove-Item Env:HTTPS_PROXY -ErrorAction SilentlyContinue
    Remove-Item Env:HTTP_PROXY -ErrorAction SilentlyContinue
    Remove-Item Env:ALL_PROXY -ErrorAction SilentlyContinue
    Write-Host "‚ùå Proxy disabled" -ForegroundColor Yellow
}

# Aliases for convenience
Set-Alias -Name proxy-on -Value Enable-Proxy
Set-Alias -Name proxy-off -Value Disable-Proxy

#endregion
{{end}}

#region Modern Tools Integration
{{if .ZshConfig.ModernTools.Replacements}}
# Modern tools and their aliases
{{range $old, $replacement := .ZshConfig.ModernTools.Replacements}}
{{if $replacement.Tool}}
# {{$old}} -> {{$replacement.Tool}}
if (Get-Command {{$replacement.Tool}} -ErrorAction SilentlyContinue) {
    {{range $alias, $cmd := $replacement.Aliases}}
    function {{$alias}} { {{$cmd}} @args }
    {{end}}
    {{range $key, $value := $replacement.EnvVars}}
    $env:{{$key}} = "{{$value}}"
    {{end}}
}{{if $replacement.Fallback}} else {
    function {{$old}} { {{$replacement.Fallback}} @args }
}{{end}}
{{end}}
{{end}}

# Common modern tool checks and aliases
if (Get-Command exa -ErrorAction SilentlyContinue) {
    Set-Alias -Name ls -Value exa -Option AllScope
    Set-Alias -Name ll -Value "exa -l" -Option AllScope
    Set-Alias -Name la -Value "exa -la" -Option AllScope
    Set-Alias -Name tree -Value "exa --tree" -Option AllScope
} elseif (Get-Command eza -ErrorAction SilentlyContinue) {
    Set-Alias -Name ls -Value eza -Option AllScope
    Set-Alias -Name ll -Value "eza -l" -Option AllScope
    Set-Alias -Name la -Value "eza -la" -Option AllScope
    Set-Alias -Name tree -Value "eza --tree" -Option AllScope
}

if (Get-Command bat -ErrorAction SilentlyContinue) {
    Set-Alias -Name cat -Value bat -Option AllScope
    $env:BAT_THEME = "ansi"
}

if (Get-Command rg -ErrorAction SilentlyContinue) {
    Set-Alias -Name grep -Value rg -Option AllScope
}

if (Get-Command fd -ErrorAction SilentlyContinue) {
    Set-Alias -Name find -Value fd -Option AllScope
}

if (Get-Command delta -ErrorAction SilentlyContinue) {
    $env:GIT_PAGER = "delta"
}
{{end}}

#endregion

{{if .ZshConfig.GitTools}}
#region Git Integration
{{range $name, $tool := .ZshConfig.GitTools}}
{{if $tool.Enabled}}
# {{$name}} aliases
{{range $alias, $cmd := $tool.Aliases}}
function {{$alias}} { {{$cmd}} @args }
{{end}}

# Git configuration
{{range $key, $value := $tool.GitConfig}}
try {
    git config --global {{$key}} "{{$value}}" 2>$null
} catch {
    # Ignore git config errors
}
{{end}}
{{end}}
{{end}}

# Enhanced git status function
function gst {
    if (Get-Command git -ErrorAction SilentlyContinue) {
        git status --short --branch
    } else {
        Write-Warning "Git is not installed or not in PATH"
    }
}

# Quick git operations
function gaa { git add --all }
function gcm { param([string]$Message) git commit -m $Message }
function gp { git push }
function gl { git pull }
function glo { git log --oneline -10 }

#endregion
{{end}}

{{if .ZshConfig.VersionManagers}}
#region Version Managers
{{range $name, $vm := .ZshConfig.VersionManagers}}
{{if $vm.Enabled}}
# {{$name}} version manager
{{if $vm.InitCommand}}
# Initialize {{$name}}
if (Test-Path "{{expandEnv $vm.InitCommand}}") {
    Invoke-Expression "{{expandEnv $vm.InitCommand}}"
}
{{end}}

{{range $key, $pathValue := $vm.EnvVars}}
$env:{{$key}} = "{{expandEnv ($pathValue.Get "windows")}}"
{{end}}

{{range $path := $vm.PathAdditions}}
$env:PATH = "{{expandEnv $path}};$env:PATH"
{{end}}
{{end}}
{{end}}

#endregion
{{end}}

#region Custom Functions

# System Information
function Get-SystemInfo {
    Write-Host "=== System Information ===" -ForegroundColor Cyan
    Write-Host "OS: {{.Platform.OS}}/{{.Platform.Architecture}}" -ForegroundColor White
    {{if .Platform.WSL}}
    Write-Host "WSL: {{.Platform.WSL.Distribution}} ({{.Platform.WSL.Version}})" -ForegroundColor White
    {{end}}
    {{if .Platform.PowerShell}}
    Write-Host "PowerShell: {{.Platform.PowerShell.Version}} ({{.Platform.PowerShell.Edition}})" -ForegroundColor White
    {{end}}
    Write-Host "User: {{.User.Name}} ({{.User.Email}})" -ForegroundColor White
    Write-Host "Editor: $env:EDITOR" -ForegroundColor White
    Write-Host "Browser: $env:BROWSER" -ForegroundColor White
    Write-Host "PowerShell Modules:" -ForegroundColor White
    Get-Module -ListAvailable | Select-Object Name, Version | Sort-Object Name | Format-Table -AutoSize
}
Set-Alias -Name sysinfo -Value Get-SystemInfo

# Enhanced directory listing
function Get-DirectorySize {
    param([string]$Path = ".")
    Get-ChildItem -Path $Path -Recurse -File | 
        Measure-Object -Property Length -Sum |
        ForEach-Object { 
            [PSCustomObject]@{
                Path = $Path
                SizeMB = [math]::Round($_.Sum / 1MB, 2)
                Files = $_.Count
            }
        }
}
Set-Alias -Name dirsize -Value Get-DirectorySize

# Quick edit functions
function Edit-Profile { 
    & $env:EDITOR $PROFILE 
}
Set-Alias -Name ep -Value Edit-Profile

function Reload-Profile { 
    . $PROFILE 
    Write-Host "‚úÖ Profile reloaded" -ForegroundColor Green
}
Set-Alias -Name rp -Value Reload-Profile

# Network utilities
function Test-Port {
    param(
        [Parameter(Mandatory)]
        [string]$ComputerName,
        [Parameter(Mandatory)]
        [int]$Port,
        [int]$Timeout = 5000
    )
    
    $tcpClient = New-Object System.Net.Sockets.TcpClient
    $connect = $tcpClient.BeginConnect($ComputerName, $Port, $null, $null)
    $wait = $connect.AsyncWaitHandle.WaitOne($Timeout, $false)
    
    if ($wait) {
        try {
            $tcpClient.EndConnect($connect)
            Write-Host "‚úÖ Port $Port is open on $ComputerName" -ForegroundColor Green
            return $true
        } catch {
            Write-Host "‚ùå Port $Port is closed on $ComputerName" -ForegroundColor Red
            return $false
        }
    } else {
        Write-Host "‚è±Ô∏è Connection to $ComputerName`:$Port timed out" -ForegroundColor Yellow
        return $false
    }
    
    $tcpClient.Close()
}

{{if .Platform.WSL}}
# WSL specific functions
function Open-Explorer {
    param([string]$Path = ".")
    explorer.exe $Path
}
Set-Alias -Name open -Value Open-Explorer

function Copy-ToClipboard {
    param([Parameter(ValueFromPipeline)]$InputObject)
    $InputObject | clip.exe
}
Set-Alias -Name clip -Value Copy-ToClipboard
{{end}}

#endregion

#region PSReadLine Configuration
if (Get-Module -Name PSReadLine -ListAvailable) {
    Import-Module PSReadLine
    
    # Enhanced editing experience
    Set-PSReadLineOption -EditMode Emacs
    Set-PSReadLineOption -BellStyle None
    Set-PSReadLineOption -PredictionSource History
    Set-PSReadLineOption -PredictionViewStyle ListView
    
    # Key bindings similar to bash/zsh
    Set-PSReadLineKeyHandler -Key Tab -Function MenuComplete
    Set-PSReadLineKeyHandler -Key Ctrl+d -Function DeleteCharOrExit
    Set-PSReadLineKeyHandler -Key Ctrl+r -Function ReverseSearchHistory
    Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward
    Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward
    
    # Colors
    Set-PSReadLineOption -Colors @{
        Command            = 'Cyan'
        Number             = 'DarkGray'
        Member             = 'DarkGray'
        Operator           = 'DarkGray'
        Type               = 'DarkGray'
        Variable           = 'Green'
        Parameter          = 'DarkGray'
        ContinuationPrompt = 'DarkGray'
        Default            = 'White'
    }
}
#endregion

{{if .ZshConfig.FzfConfig.Enabled}}
#region FZF Integration
if (Get-Command fzf -ErrorAction SilentlyContinue) {
    # FZF environment variables
    {{range $key, $cmd := .ZshConfig.FzfConfig.Commands}}
    $env:FZF_{{upper $key}}_COMMAND = "{{$cmd}}"
    {{end}}
    
    {{if .ZshConfig.FzfConfig.Theme}}
    $env:FZF_DEFAULT_OPTS = "{{range $key, $value := .ZshConfig.FzfConfig.Theme}}--{{$key}} {{$value}} {{end}}"
    {{end}}
    
    # FZF helper functions
    function Invoke-FuzzySearch {
        param([string]$Query = "")
        fzf --query=$Query
    }
    Set-Alias -Name fz -Value Invoke-FuzzySearch
    
    function Set-LocationFuzzy {
        $result = Get-ChildItem -Directory | fzf
        if ($result) {
            Set-Location $result.FullName
        }
    }
    Set-Alias -Name cdf -Value Set-LocationFuzzy
}
#endregion
{{end}}

#region Performance and Cleanup
# Remove duplicate entries from PATH
$env:PATH = ($env:PATH -split ';' | Sort-Object -Unique) -join ';'

# Calculate and display profile load time
$ProfileLoadTime = (Get-Date) - $ProfileStartTime
Write-Host "‚úÖ Profile loaded in $($ProfileLoadTime.TotalMilliseconds)ms" -ForegroundColor Green

# Clean up temporary variables
Remove-Variable ProfileStartTime, ProfileLoadTime -ErrorAction SilentlyContinue
#endregion

#region Module Auto-loading
# List of useful modules to auto-import
$AutoImportModules = @(
    'Microsoft.PowerShell.Utility'
    'Microsoft.PowerShell.Management'
)

foreach ($ModuleName in $AutoImportModules) {
    if (Get-Module -Name $ModuleName -ListAvailable) {
        Import-Module $ModuleName -Global -ErrorAction SilentlyContinue
    }
}
#endregion

#region Local Customizations
# Load local customizations if they exist
$LocalProfile = Join-Path $PSScriptRoot "profile.local.ps1"
if (Test-Path $LocalProfile) {
    Write-Host "üìÇ Loading local customizations..." -ForegroundColor DarkGray
    . $LocalProfile
}

# Alternative local profile location
$LocalProfile2 = "$env:USERPROFILE\.config\powershell\profile.local.ps1"
if (Test-Path $LocalProfile2) {
    Write-Host "üìÇ Loading user local customizations..." -ForegroundColor DarkGray
    . $LocalProfile2
}
#endregion

# =============================================================================
# End of Profile
# =============================================================================

Write-Host "üéâ PowerShell Profile Ready!" -ForegroundColor Magenta